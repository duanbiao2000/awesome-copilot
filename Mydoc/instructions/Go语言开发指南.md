# Go 语言开发指南

## 核心技术简介

Go（又称 Golang）是 Google 开发的开源编程语言，以其简洁的语法、强大的并发支持和高效的编译性能而闻名。Go 语言特别适合构建高性能的网络服务、分布式系统和云原生应用，拥有丰富的标准库和活跃的社区生态。

## 命名规范

### 包命名

- 使用小写单单词名称，避免下划线、连字符或混合大小写
- 选择描述包功能而非内容的名称
- 避免使用 `util`、`common`、`base` 等通用名称
- 包名应为单数形式

### 变量和函数命名

- 使用驼峰式命名（camelCase），避免下划线
- 保持名称简短但具有描述性
- 仅在作用域很小时使用单字母变量（如循环索引）
- 导出名称首字母大写，未导出名称首字母小写
- 避免命名冗余（如避免 `http.HTTPServer`，推荐 `http.Server`）

### 接口命名

- 尽可能使用 -er 后缀（如 `Reader`、`Writer`、`Formatter`）
- 单方法接口应以方法名命名（如 `Read` → `Reader`）
- 保持接口小而专注

## 代码风格与格式

### 格式化

- 始终使用 `gofmt` 格式化代码
- 使用 `goimports` 自动管理导入
- 保持合理行长度，注重可读性
- 使用空行分隔逻辑代码组

### 注释规范

- 优先编写自文档化代码，仅在必要时添加注释
- 用完整英文句子编写注释
- 包注释以 "Package [name]" 开头
- 主要使用行注释（[//](file://d:\Mycodes\Gitrepos\awesome-copilot\CODE_OF_CONDUCT.md)），块注释（`/* */`）谨慎使用

## 错误处理

### 错误检查

- 函数调用后立即检查错误
- 除非有充分理由，不要忽略错误（使用 `_`）
- 使用 `fmt.Errorf` 和 `%w` 动词包装错误添加上下文
- 将错误返回作为最后一个返回值
- 错误变量命名为 `err`
- 错误消息使用小写，不以标点符号结尾

### 自定义错误

- 简单静态错误使用 `errors.New`
- 动态错误使用 `fmt.Errorf`
- 领域特定错误创建自定义错误类型
- 导出错误变量用于哨兵错误
- 使用 `errors.Is` 和 `errors.As` 进行错误检查

## 并发编程

### Goroutine 使用

- 在库中创建 goroutine 时要谨慎，优先让调用者控制并发
- 始终知道 goroutine 如何退出
- 使用 `sync.WaitGroup` 或通道等待 goroutine 完成
- 避免 goroutine 泄漏，确保清理

### 通道通信

- 使用通道在 goroutine 间通信
- 遵循"通过通信共享内存，而非通过共享内存通信"
- 发送方关闭通道，非接收方
- 根据容量需求使用缓冲通道
- 使用 `select` 实现非阻塞操作

### 同步机制

- 使用 `sync.Mutex` 保护共享状态
- 保持临界区小
- 多读少写场景使用 `sync.RWMutex`
- 根据使用场景选择通道或互斥锁
- 一次性初始化使用 `sync.Once`

## 类型安全与语言特性

### 类型定义

- 定义类型以增加含义和类型安全
- 使用结构体标签进行 JSON、XML、数据库映射
- 优先使用显式类型转换
- 谨慎使用类型断言，检查第二个返回值

### 指针与值

- 大结构体或需要修改接收者时使用指针接收者
- 小结构体或需要不可变性时使用值接收者
- 需要修改参数或大结构体时使用指针参数
- 小结构体且防止修改时使用值参数
- 在类型方法集中保持一致性

## 项目架构与依赖管理

### 包组织

- 遵循标准 Go 项目布局约定
- `main` 包放在 `cmd/` 目录
- 可重用包放在 `pkg/` 或 `internal/`
- 使用 `internal/` 存放不应被外部项目导入的包
- 将相关功能分组到包中
- 避免循环依赖

### 依赖管理

- 使用 Go 模块（`go.mod` 和 `go.sum`）
- 保持依赖最小化
- 定期更新依赖以获取安全补丁
- 使用 `go mod tidy` 清理未使用依赖
- 仅在必要时 vendor 依赖

## 性能优化

### 内存管理

- 最小化热点路径中的内存分配
- 可能时重用对象（考虑 `sync.Pool`）
- 小结构体使用值接收者
- 已知大小时预分配切片
- 避免不必要的字符串转换

### I/O 优化

- 大多数 `io.Reader` 流只能消费一次
- 多次读取时缓冲数据并按需重建读取器
- HTTP 请求中不重用已消费的 `req.Body`
- 使用 `io.Pipe` 实现流式处理而无需缓冲整个有效载荷

## 测试实践

### 测试组织

- 同包测试（白盒测试）或使用 `_test` 后缀（黑盒测试）
- 测试文件使用 `_test.go` 后缀
- 测试文件与被测试代码放在一起

### 测试编写

- 多测试用例使用表驱动测试
- 使用描述性命名 `Test_functionName_scenario`
- 使用 `t.Run` 子测试更好组织
- 测试成功和错误场景
- 适当使用 `testify` 等库

## 安全最佳实践

### 输入验证

- 验证所有外部输入
- 使用强类型防止无效状态
- SQL 查询前清理数据
- 谨慎处理用户输入的文件路径
- 不同上下文验证和转义数据（HTML、SQL、shell）

### 密码学

- 使用标准库加密包
- 不要自己实现加密算法
- 使用 `crypto/rand` 生成随机数
- 密码存储使用 bcrypt、scrypt 或 argon2
- 网络通信使用 TLS

## 开发工具与工作流

### 必备工具

- `go fmt`：代码格式化
- `go vet`：发现可疑结构
- `golangci-lint`：额外的代码检查
- `go test`：运行测试
- `go mod`：依赖管理
- `go generate`：代码生成

### 开发实践

- 提交前运行测试
- 使用预提交钩子进行格式化和检查
- 保持提交专注和原子性
- 编写有意义的提交消息
- 提交前审查差异

## 常见陷阱避免

- 不检查错误
- 忽略竞态条件
- 创建 goroutine 泄漏
- 不使用 defer 进行清理
- 并发修改 map
- 不理解 nil 接口与 nil 指针
- 忘记关闭资源（文件、连接）
- 不必要使用全局变量
- 过度使用无约束类型（如 `any`）
- 不考虑类型的零值
- 创建重复的 `package` 声明（编译错误）
